#lang racket

;;; formulating iterations as a stream processes
(define (sqrt-improve guess x)
  (/ (+ guess (/ x guess)) 2))


(define (sqrt-stream x)
  (define guesses
    (stream-cons 1.0
                 (stream-map
                  (lambda (guess) (sqrt-improve guess x))
                  guesses)))
  guesses)

(provide sqrt-stream)

;;; pi stream
(require "ex-55.rkt")
(define (pi-summands n)
  (stream-cons (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))
(define pi-stream
  (stream-map
   (lambda (x) (* x 4))
   (partial-sums (pi-summands 1))))


(define (euler-transform s)
  (let ([s0 (stream-ref s 0)]
        [s1 (stream-ref s 1)]
        [s2 (stream-ref s 2)])
    (stream-cons
     (- s2 (/ (* (- s2 s1) (- s2 s1))
              (+ s0 (* -2 s1) s2)))
     (euler-transform (stream-rest s)))))

(define (make-tableau transform s)
  (stream-cons s
               (make-tableau
                transform
                (transform s))))

(define (accelerated-sequence transform s)
  (stream-map stream-first
              (make-tableau transform s)))

(provide euler-transform accelerated-sequence)

;;;
(define pi-stream-super-accelerated
  (accelerated-sequence euler-transform pi-stream))
